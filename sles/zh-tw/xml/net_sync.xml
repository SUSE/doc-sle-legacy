<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN"
"novdocx.dtd">
<!--
*********************************
Please see LICENSE.txt for this document's license.
*********************************
-->
<chapter xml:base="net_sync.xml" id="cha.net.sync">
 <title>檔案同步化</title><indexterm id="idx.files_syncronizing" class="startofrange"> <primary>檔案</primary> <secondary>同步化</secondary> </indexterm>
 <abstract>
  <para>
   現在，許多人都使用多台電腦 — 家裡一台、辦公室一台或數台，出門在外還使用筆記型電腦、平板電腦或智慧型手機。許多檔案都需要各存一份在所有這些電腦上。您可能希望所有電腦能一起工作、修改檔案，這樣就能讓所有電腦都擁有最新的資料。
  </para>
 </abstract>
 <sect1 id="sec.net.sync.soft">
  <title>可用的資料同步化軟體</title>

  <para>
   對於永久以快速網路連結的電腦而言，資料同步化不是問題。在此狀況下，使用 NFS 之類的網路檔案系統，並將檔案儲存在伺服器上，所有主機就可以透過網路來存取相同的資料。但如果網路連接品質很差或不是永久的，就無法使用此方法。當您出門在外使用筆記型電腦時，所有需要的檔案複本都必須在本地硬碟上。不過之後需要將修改過的檔案同步化。當您在某一台電腦上修改檔案時，請確定也更新了所有其他電腦上的同一檔案。至於一些零散的複本，則可以使用 scp 或 rsync 手動更新它。然而，如果有許多檔案需要處理，則該程序有可能變得很複雜，而且需要更小心才能避免類似以舊檔案覆寫新檔案的錯誤。
  </para>

  <warning>
   <title>資料遺失的風險</title>
   <para>
    在您開始使用同步化系統管理資料之前，應該先好好的認識要使用的程式並測試其功能。對於重要檔案而言，備份是不可或缺的動作。
   </para>
  </warning>

  <para>
   手動同步化資料非常耗時，而且是一種容易發生錯誤的任務，要避免這些缺點，可以使用一種以多種方法將此工作自動化的程式。下列摘要讓您概略瞭解這些程式的運作方式和使用方法。如果您打算使用它們，請詳閱程式文件。
  </para>

  <sect2 id="sec.net.sync.soft.cvs">
   <title>CVS</title><indexterm> <primary>檔案</primary> <secondary>同步化</secondary> <tertiary>CVS</tertiary> </indexterm> <indexterm> <primary>CVS</primary> </indexterm>
   <para>
    CVS 主要用來管理程式來源版本，它能在多台電腦上保留檔案副本。因此，它也適用於資料同步化。CVS 負責維謢伺服器上的中央儲存庫，檔案及檔案的變更都儲存在此。在本地執行的變更會交付至儲存庫，並且可以利用更新從其他電腦擷取。兩個程序都必須由使用者起始。
   </para>
   <para>
    CVS 對於錯誤有非常大的彈性與包容性，所以可以應付多台電腦同時進行變更的情況。所有變更會合併，如果同一行發生多種變更，系統還會報告衝突。衝突發生時，資料庫會維持一致的狀態。只有在用戶端主機上才能看到衝突，並加以解決。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.soft.rsync">
   <title>rsync</title><indexterm> <primary>rsync</primary></indexterm><indexterm><primary>檔案</primary><secondary>同步化</secondary><tertiary>rsync </tertiary></indexterm>
   <para>
    當不需要版本控制，但是大型目錄結構需要透過緩慢的網路連接進行同步化時，rsync 工具針對僅傳送檔案中的變更可提供已開發成熟的機制。這不只適用於文字檔，也適用於二進位檔。為了偵測檔案之間的不同，rsync 會將檔案分為區塊並計算它們的檢查總數。
   </para>
   <para>
    偵測變更將需要付出相當大的成本。要同步化的系統應該要具有相當的硬體配備，才能使用 rsync。RAM 尤其重要。
   </para>
  </sect2>




 </sect1>
 <sect1 id="sec.net.sync.select">
  <title>選取程式時所要考慮的決定性因素</title>

  <para>
   在決定要使用哪個程式時，必須考慮一些重要的因素。
  </para>

  <sect2 id="sec.net.sync.select.client-server">
   <title>用戶端對伺服器與點對點</title>
   <para>
    配送資料時常使用的模式有兩種。第一個模式是，所有的用戶端都以中央伺服器為準，將其檔案同步化。伺服器至少必須偶爾可以讓所有的用戶端存取。CVS 使用此模式。
   </para>
   <para>
    另一種可能性就是，讓網路上所有主機都以點對點的方式將彼此間的資料同步化。rsync 實際作用於用戶端模式，但任何用戶端都可以當作伺服器使用。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.port">
   <title>可攜式</title>
   <para>
    在許多其他的作業系統上也可以使用 CVS 以及 rsync，包含各種 Unix 與 Windows 系統。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.auto">
   <title>互動式與自動化</title>
   <para>
    在 CVS 中，資料同步化是由使用者以手動方式啟動。這讓使用者對於要同步化的資料進行良好的控制，並可輕鬆地處理衝突。然而，如果同步化間隔太長，就比較可能發生衝突。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.problems">
   <title>衝突：發生與解決</title>
   <para>
    即使有數個人員同時在某個大型的程式專案上一起工作，在 CVS 中發生衝突的機率還是相當地少。這是因為文件是在個別的行列上進行合併。當發生衝突時，只有一個用戶端會受到影響。CVS 中的衝突通常都可以輕易解決。
   </para>
   <para>
    rsync 中則無衝突處理功能。使用者必須小心不要覆寫檔案，並手動解決所有可能的衝突。為確保安全，另外還可使用版本設定系統 (如 RCS)。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.files">
   <title>選取和新增檔案</title>
   <para>
    在 CVS 中，必須分別使用 <command>cvs</command> 或 <option>add </option>指令，明確地新增目錄與檔案。這讓使用者對於要同步化的檔案擁有更大的控制權。另一方面，新檔案時常會被忽略，特別是在處理大量的檔案而忽略了 <command>cvs</command> 以及 <option>update</option> 輸出中的問號時。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.history">
   <title>歷程</title>
   <para>
    CVS 還有另一項功能，那就是可以重新建構舊的檔案版本。每個變更都可以插入簡短的編輯符號，而且之後可以根據其內容與符號輕易地追蹤檔案的發展。這對論文與程式文字而言，是一種很珍貴的助力。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.size">
   <title>資料量與硬碟需求</title>
   <para>
    所有相關主機的硬碟都需要有足夠的可用空間來儲存所有分散式的資料。CVS 在伺服器上還需要額外的空間，供儲存庫資料庫使用。檔案歷程記錄也會儲存在伺服器上，因此需要更多的空間。當文字格式的檔案變更時，只需儲存修改過的那幾行。每當變更檔案時，二進位檔案就會需要與該檔案大小相同的額外空間。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.gui">
   <title>GUI</title>
   <para>
    有經驗的使用者通常會從指令行執行 CVS。然而，在 cervisia 之類的 Linux 系統中，以及 wincvs 之類的其他作業系統中，都有圖形使用者介面。此外，許多開發工具 (像是 kdevelop) 以及文字編輯器 (像是 Emacs) 都支援 CVS。使用這些前端程式的話，衝突的解決方案通常會更容易執行。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.use">
   <title>使用者親切性</title>
   <para>
    rsync 較易於使用且適合新進人員。CVS 某種程度上較難操作。使用者必須瞭解儲存庫與本地資料之間的互動。對資料的變更應該先在本地與儲存庫合併。這是使用 <command>cvs</command> 或 <option>update</option> 指令來執行。接著必須使用 <command>cvs</command> 或 <option>commit</option> 指令將資料傳送回儲存庫。只要瞭解此程序，新進人員就可輕鬆使用 CVS。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.sec">
   <title>防止攻擊的安全性</title>
   <para>
    在傳輸期間，應該保護資料以防攔截和竄改。CVS 與 rsync 都可以透過 ssh (安全的外圍程式) 來使用，提供安全性以防護此類攻擊。應該避免透過 rsh (遠端外圍程式) 執行 CVS。同樣地不建議在不安全的網路中使用 <emphasis>pserver</emphasis> 機制存取 CVS。
   </para>
  </sect2>

  <sect2 id="sec.net.sync.select.loss">
   <title>針對資料遺失的防護</title>
   <para>
    開發人員使用 CVS 來管理程式專案已經有很長的一段時間，而且極為穩定。因為開發的歷程記錄皆已儲存，所以 CVS 甚至提供保護，防止某些使用者錯誤發生，例如不小心刪除檔案。
   </para>
   <table id="tab.sync_overview">
    <title>檔案同步化工具的功能：-- = 很差，- = 差或無法使用，o = 中等，+ = 良好，++ = 優異，x = 可用</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>
        <para/>
       </entry>
       <entry>
        <para>
         CVS
        </para>
       </entry>
       <entry>
        <para>
         rsync
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         主/從
        </para>
       </entry>
       <entry>
        <para>
         C-S
        </para>
       </entry>
       <entry>
        <para>
         C-S
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         可攜式
        </para>
       </entry>
       <entry>
        <para>
         Lin、Un*x、Win
        </para>
       </entry>
       <entry>
        <para>
         Lin、Un*x、Win
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         互動
        </para>
       </entry>
       <entry>
        <para>
         x
        </para>
       </entry>
       <entry>
        <para>
         x
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         速度
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
       <entry>
        <para>
         +
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         衝突
        </para>
       </entry>
       <entry>
        <para>
         ++
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         檔案 Sel。
        </para>
       </entry>
       <entry>
        <para>
         Sel./file, dir.
        </para>
       </entry>
       <entry>
        <para>
         目錄
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         歷程
        </para>
       </entry>
       <entry>
        <para>
         x
        </para>
       </entry>
       <entry>
        <para>
         -
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         硬碟空間
        </para>
       </entry>
       <entry>
        <para>
         --
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         GUI
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
       <entry>
        <para>
         -
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         困難度
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
       <entry>
        <para>
         +
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         攻擊
        </para>
       </entry>
       <entry>
        <para>
         + (ssh)
        </para>
       </entry>
       <entry>
        <para>
         +(ssh)
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         資料損失
        </para>
       </entry>
       <entry>
        <para>
         ++
        </para>
       </entry>
       <entry>
        <para>
         +
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>
 <sect1 id="sec.net.sync.cvs">
  <title>CVS 簡介</title><indexterm id="idx.CVS" class="startofrange"> <primary>CVS</primary> </indexterm> <indexterm id="idx.files_synchronizing_CVS" class="startofrange"> <primary>檔案</primary> <secondary>同步化</secondary> <tertiary>CVS</tertiary> </indexterm>

  <para>
   如果經常編輯某些個別檔案，並且以檔案格式儲存，例如 ASCII 文字或程式來源文字，就非常適合使用 CVS 進行同步化。您可以使用 CVS 同步化其他格式的資料 (例如 JPEG 檔案)，但是會產生大量的資料，因為檔案的所有變體都會永久儲存在 CVS 伺服器上。在這種情形下，CVS 的大部份功能都將無法使用。只有在所有工作站都可以存取同一伺服器時，才能使用 CVS 同步化檔案。
  </para>

  <sect2>
   <title>設定 CVS 伺服器</title>
   <para>
    <emphasis>server</emphasis> 是所有有效檔案所在的主機，這包含所有檔案的最新版本。任何靜態工作站都可做為伺服器。可能的話，CVS 儲存庫的資料應該包含在定期備份中。
   </para>
   <para>
    當設定 CVS 伺服器時，透過 SSH 授予使用者該伺服器的存取權可能是不錯的方式。如果使用者是以 <systemitem class="username">tux</systemitem> 的身份登入伺服器，而且 CVS 軟體既安裝在伺服器上也安裝在用戶端上，則必須在用戶端上設定下列環境變數：
   </para>
<screen><?dbsuse-latex font-size="footnotesize" ?>


CVS_RSH=ssh CVSROOT=tux@server:/serverdir</screen>
   <para>
    <command>cvs</command><option>init</option> 指令可用來從用戶端啟始 CVS 伺服器。這只需要做一次。
   </para>
   <para>
    最後，必須為同步化指定名稱。在用戶端上選取或建立一個目錄，用於存放 CVS 所管理的檔案 (目錄也可以是空的)。該目錄的名稱也就是同步化的名稱。在此範例中，該目錄稱為 <literal>synchome</literal>。變更至此目錄，然後輸入下列指令將同步化名稱設為 <literal>synchome</literal>：
   </para>
<screen>cvs import synchome tux wilber</screen>
   <para>
    許多 CVS 指令需要註解。因此，CVS 會啟動編輯器 (如果沒有定義編輯器，則會啟動環境變數 <literal>$EDITOR</literal> 或 vi 中所定義的編輯器。)在指令行先輸入註解，就可以避免編輯器的呼叫，如下列範例所示：
   </para>
<screen>cvs import -m 'this is a test' synchome tux wilber</screen>
  </sect2>

  <sect2>
   <title>使用 CVS</title>
   <para>
    現在可以使用 <command>cvs</command><option>co synchome</option> 從所有主機取出同步化儲存庫。這會在用戶端上建立新的子目錄 <filename>synchome</filename>。若要將變更交付至伺服器，請換至 <filename>synchome</filename> 目錄 (或其中一個子目錄)，然後輸入 <command>cvs</command><option>commit</option>。
   </para>
   <para>
    根據預設，所有的檔案 (包括子目錄) 都會交付給伺服器。若只要交付個別的檔案或目錄，請在 <command>cvs</command><option>commit file1 directory1 </option>中指定它們。在將它們交付至伺服器前，必須使用像是 <command>cvs</command><option>add file1 directory1</option> 之類的指令，將新檔案與目錄新增至儲存庫。接著，使用 <command>cvs</command><option>commit file1 directory1 </option>交付新增的檔案與目錄。
   </para>
   <para>
    您更換至另一個工作站時，如果先前的工作階段尚未取出該工作站的同步化儲存庫，請現在取出。
   </para>
   <para>
    使用 <command>cvs</command><option>update </option>啟動與伺服器的同步化。依照 <command>cvs</command><option>update file1 directory1</option> 中的個別檔案或目錄來更新。若要查看目前檔案與伺服器上所存版本的差異，請使用 <command>cvs</command><option>diff</option> 或 <command>cvs</command><option>diff file1 directory1</option> 指令。使用 <command>cvs</command><option>-nq update</option> 來查看哪些檔案會受到更新的影響。
   </para>
   <para>
    以下是更新期間所顯示的一些狀態符號：
   </para>
   <variablelist>
    <varlistentry>
     <term>U</term>
     <listitem>
      <para>
       已更新本地版本。這將會影響伺服器所提供及在本地系統上所遺失的全部檔案。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>M</term>
     <listitem>
      <para>
       已修改本地版本。如果在伺服器上有一些變更，可以在本地複本中將差異合併。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>P</term>
     <listitem>
      <para>
       本地版本已使用伺服器版本修補。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>C</term>
     <listitem>
      <para>
       本地檔案與儲存庫中目前的版本衝突。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>?</term>
     <listitem>
      <para>
       這個檔案並不存在於 CVS。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    <literal>M</literal> 狀態是指在本地修改過的檔案。或是將本地複本交付至伺服器，或是移除本地檔案後再執行一次更新。在此例中，會從伺服器擷取遺失的檔案。如果您交付本地已修改的檔案，而該檔案是在同一行中變更並交付，則有可能造成衝突，這是以 <literal>C</literal> 表示。
   </para>
   <para>
    如果發生這種狀況，請檢視檔案中的衝突記號 (<quote><literal>&gt;&gt;</literal></quote> 與 <quote><literal>&lt;&lt;</literal></quote>)，並在兩個版本之間選擇一個。這有可能是相當麻煩的工作，您可能會決定捨棄變更、刪除本地檔案，然後輸入 <command>cvs</command><option>up</option>，以便從伺服器擷取目前的版本。
   </para><indexterm class="endofrange" startref="idx.CVS"/><indexterm class="endofrange" startref="idx.files_synchronizing_CVS"/>
  </sect2>
 </sect1>
 <sect1 id="sec.net.sync.rsync">
  <title>rsync 簡介</title><indexterm> <primary>rsync</primary> </indexterm>

  <para>
   當有大量的資料需要定期傳輸，但是並無太多變更時，rsync 就非常有用。例如，當建立備份時就非常適用。另一個應用程式則將焦點放在建置伺服器。這些伺服器儲存了網頁伺服器的完整目錄樹狀結構，會定期鏡像複製至 DMZ 中的網頁伺服器。
  </para>

  <sect2>
   <title>組態與作業</title>
   <para>
    rsync 可以使用兩個模式來操作。它是用來歸檔或複製資料。若要完成此動作，在目標系統上只需要像是 ssh 的遠端外圍程序。然而，rsync 也可以像 daemon 一樣，用來為網路提供目錄。
   </para>
   <para>
    rsync 的基本作業模式並不需要任何特殊的組態。rsync 直接允許將完整的目錄鏡像複製至另一個系統。例如，下列指令可在名為 Sun 的備份伺服器上建立 Tux 主目錄的備份：
   </para>
<screen>rsync -baz -e ssh /home/tux/ tux@sun:backup</screen>
   <para>
    下列指令可用來還原目錄：
   </para>
<screen>rsync -az -e ssh tux@sun:backup /home/tux/</screen>
   <para>
    到此為止，其處理方式與一般的複製工具 (例如 scp) 的處理沒有太大的差別。
   </para>
   <para>
    rsync 應該在 <quote>rsync</quote> 模式中操作，才能充分使用其所有的功能。執行方法是在其中一個系統上啟動 rsyncd 精靈。在 <filename>/etc/rsyncd.conf</filename> 檔案中設定它。例如，如果要讓 <filename>/srv/ftp</filename> 目錄可供 rsync 使用，請使用下列組態：
   </para>
<screen>gid = nobody
uid = nobody
read only = true
use chroot = no
transfer logging = true
log format = %h %o %f %l %b
log file = /var/log/rsyncd.log

[FTP]
        path = /srv/ftp
        comment = An Example</screen>
   <para>
    接著使用 <command>rcrsyncd</command><option>start</option> 來啟動 rsyncd。在開機程序期間也可以自動啟動 rsyncd。設定的方式有兩種，一是在 YaST 所提供的執行層級編輯器中啟動此服務，另一是手動輸入 <command>insserv</command> <option>rsyncd</option> 指令。rsyncd 也可以由 xinetd 啟動。然而，只有對很少使用 rsyncd 的伺服器才建議這麼做。
   </para>
   <para>
    本範例也建立了傾聽所有連接的記錄檔。這個檔案是儲存在 <filename>/var/log/rsyncd.log</filename>。
   </para>
   <para>
    這樣才可以從用戶端系統測試傳輸。使用下列指令來執行此動作：
   </para>
<screen>rsync -avz sun::FTP</screen>
   <para>
    此指令會列出伺服器上 <filename>/srv/ftp</filename> 目錄中所有存在的檔案。這個要求也會記錄在 <filename>/var/log/rsyncd.log</filename> 記錄檔中。若要啟動實際的傳輸，請提供目標目錄。請使用 <literal>. </literal> 來代表目前的目錄。例如：
   </para>
<screen>rsync -avz sun::FTP .</screen>
   <para>
    依照預設，在使用 rsync 同步化時不會刪除檔案。如果要強制刪除檔案，就必須加上額外的選項 <option>--delete</option>。若要確保不會刪除較新的檔案，則可以改用 <option>--update</option> 選項。任何產生的衝突都必須手動解決。
   </para>
  </sect2>
 </sect1>
 <sect1 id="sec.net.sync.summary">
  <title>更多資訊</title>

  <variablelist>
   <varlistentry>
    <term>CVS</term>
    <listitem>
     <para>
      可在首頁 <ulink url="http://www.cvshome.org"/> 找到有關 CVS 的重要資訊。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>rsync</term>
    <listitem>
     <para>
      關於 rsync 的重要資訊，請參閱手冊頁面。指令為 <command>man</command><option>rsync</option> 和 <command>man</command><option>rsyncd.conf</option>。如需關於 rsync 作業原則的技術參考資料，可在 <filename>/usr/share/doc/packages/rsync/tech_report.ps</filename> 中找到。您可以在專案網站 <ulink url="http://rsync.samba.org/"/> 上找到關於 rsync 的最新消息。
     </para>
    </listitem>
   </varlistentry>
   
  </variablelist><indexterm class="endofrange" startref="idx.files_syncronizing"/>
 </sect1>
</chapter>
