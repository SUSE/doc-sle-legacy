<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN"
"novdocx.dtd">
<!--
*********************************
Please see LICENSE.txt for this document's license.
*********************************
-->
<chapter xml:base="64bit_issues.xml" id="cha.64bit">
 <title>64 位系统环境中的 32 位和 64 位应用程序</title><indexterm> <primary>64 位 Linux</primary> </indexterm>
 <para>
  <phrase role="productname"><phrase os="sles">SUSE® Linux Enterprise Server</phrase></phrase> 可用于<phrase os="sles">多种</phrase> 64 位平台。但是这并不表示内含的所有应用程序都已移植到 64 位平台上。<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 支持在 64 位系统环境中使用 32 位应用程序。本章简单介绍了如何在 64 位<phrase role="productname"><phrase os="sles"> SUSE Linux Enterprise Server</phrase></phrase> 平台上实现这种支持。它解释了如何执行 32 位应用程序（运行时支持）以及应该如何编译 32 位应用程序以使它们既可以在 32 位系统环境中运行，又可以在 64 位系统环境中运行。另外，您还可以了解有关内核 API 的信息和 32 位应用程序如何在 64 位内核下运行的解释。
 </para>
 <para>
  <phrase os="sles">用于 64 位平台 ia64、ppc64、System z 和 x86_64 的 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase></phrase> 可让现有的 32 位应用程序<quote>无需额外配置</quote>即可在 64 位环境中运行。<phrase os="sles">相应的 32 位平台是 x86（对于 ia64）、ppc（对于 ppc64）和 x86（对于 x86_64）。</phrase>这种支持意味着您可以继续使用所需的 32 位应用程序，而无需等待对应的 64 位端口可用。<phrase os="sles">当前的 ppc64 系统以 32 位方式运行大多数应用程序，但您可以运行 64 位应用程序。</phrase>
 </para>
 <sect1 id="sec.64bit.runt">
  <title>运行时支持</title><indexterm> <primary>64 位 Linux</primary> <secondary>运行时支持</secondary> </indexterm>

  <important>
   <title>应用程序版本之间的冲突</title>
   <para>
    如果某个应用程序在 32 位和 64 位环境中都可用，则两个版本的并行安装必定会导致出现问题。在这种情况下，在两个版本中选一个，然后安装并使用这一版本。
   </para>
   <para>
    此规则的一个例外是 PAM（可插入身份验证模块）。<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 在身份验证过程中使用 PAM 作为在用户和应用程序之间充当媒介的层。在另外还运行 32 位应用程序的 64 位操作系统上，始终需要安装两个版本的 PAM 模块。
   </para>
  </important>

  <para>
   若要正确执行，每个应用程序都需要一系列库。不巧的是，这些库的 32 位和 64 位版本的名称是相同的。必须通过另一种方法对它们加以区分。
  </para>

  <para>
   为了保持与 32 位版本的兼容性，这些库在系统中的储存位置与在 32 位环境中相同。在 32 位和 64 位环境中，<filename>libc.so.6</filename> 的 32 位版本都位于 <filename>/lib/libc.so.6</filename> 下。
  </para>

  <para>
   所有 64 位库和对象文件都位于名为 <filename>lib64</filename> 的目录中。通常预计会在 <filename>/lib</filename> 和 <filename>/usr/lib</filename> 下找到的 64 位对象文件，现在可以在 <filename>/lib64</filename> 和 <filename>/usr/lib64</filename> 下找到。这意味着 <filename>/lib</filename> 和 <filename>/usr/lib</filename> 下有储存 32 位库的空间，因此两个版本的文件名都可以保持不变。
  </para>

  <para>
   如果 32 位 <filename>/lib</filename> 目录的子目录包含的数据内容不依赖于字大小，则不移动这些目录。此方案符合 LSB（Linux 标准库）和 FHS（文件系统层次标准）。
  </para>

  <para os="sles" arch="ipf">
   ia64 的 64 位库位于标准的 <filename>lib</filename> 目录中，没有 <filename>lib64</filename> 目录或 <filename>lib32</filename> 目录。ia64 在仿真下执行 32 位 x86 代码。一组基本库将安装在 <filename>/emul/ia32-linux/lib</filename> 和 <filename>/emul/ia32-linux/usr/lib</filename> 中。
  </para>


 </sect1>
 <sect1 id="sec.64bit.devel">
  <title>软件开发</title><indexterm> <primary>64 位 Linux</primary><secondary>软件开发</secondary> </indexterm>

  <para os="sles">
   所有 64 位体系结构都支持 64 位对象的开发。32 位编译的支持级别取决于体系结构。GCC（GNU 编译器集合）和 binutils（包括汇编器 <command>as</command> 和链接器 <command>ld</command>）中的工具链有多个实施选项：
  </para>

  <variablelist os="sles">
   <varlistentry>
    <term>Biarch 编译器</term>
    <listitem>
     <para>
      使用 biarch 开发工具链可以生成 32 位对象和 64 位对象。biarch 开发工具链允许生成 32 位和 64 位对象。在几乎所有平台上，默认设置都是编译 64 位对象。如果使用特殊的标志，则可以生成 32 位对象。特殊标志是 <option>-m32</option>（对于 GCC）。用于 binutils 的标志是依赖于体系结构的，但 GCC 将正确的标志传送到链接器和汇编器。现有 amd64（支持 x86 和 amd64 指令的开发）、System z 和 ppc64 的 biarch 开发工具链。32 位对象通常是在 ppc64 平台上创建的。<literal>-m64</literal> 标志用于生成 64 位对象。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>无支持</term>
    <listitem>
     <para>
      <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 当前不支持在所有平台上直接开发 32 位软件。要在 ia64 下开发用于 x86 的应用程序，请使用对应的 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 32 位版本。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  

  <para>
   必须以一种独立于体系结构的形式编写所有头文件。安装的 32 位和 64 位库必须具有与安装的头文件匹配的 API（应用程序编程接口）。普通 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 环境是根据此原则设计的。如果是手动更新的库，请自行解决此问题。
  </para>
 </sect1>
 <sect1 id="sec.64bit.biarch">
  <title>Biarch 平台上的软件编译</title>

  <para>
   若要在 Biarch 体系结构上为其他体系结构开发二进制代码，则必须另外安装用于第二个体系结构的各个库。这些包称为 <systemitem class="resource">rpmname-32bit</systemitem><phrase os="sles"> 或 <systemitem class="resource">rpmname-x86</systemitem>（针对 ia64，如果第二个体系结构为 32 位体系结构），或者 <systemitem class="resource">rpmname-64bit</systemitem>（如果第二个体系结构为 64 位体系结构）</phrase>。您还需要 <systemitem class="resource">rpmname-devel</systemitem> 包中各自的报头和库以及 <systemitem class="resource">rpmname-devel-32bit</systemitem><phrase os="sles"> 或 <systemitem class="resource">rpmname-devel-64bit</systemitem></phrase> 中用于第二个体系结构的开发库。
  </para>

  <para os="sles">
   例如，要在第二个体系结构为 32 位体系结构的系统（x86_64 或 System z）上编译使用 <command>libaio</command> 的程序，则需要以下 RPM：
  </para>

  <variablelist os="sles">
   <varlistentry>
    <term>libaio-32bit</term>
    <listitem>
     <para>
      32 位运行时包
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>libaio-devel-32bit</term>
    <listitem>
     <para>
      32 位开发的标题和库
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>libaio</term>
    <listitem>
     <para>
      64 位运行时包
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>libaio-devel</term>
    <listitem>
     <para>
      64 位开发的标题和库
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   大多数开放源代码程序使用基于 <command>autoconf</command> 的程序配置。若要使用 <command>autoconf</command> 配置第二个体系结构的程序，请通过运行带有附加环境变量的 <command>configure</command> 脚本覆盖 <command>autoconf</command> 的常规编译器和链接器设置。
  </para>

  <para>
   以下示例代表的是使用 x86 作为第二个体系结构的 x86_64 系统。<phrase os="sles">第二个体系结构为 ppc 的 ppc64 的示例类似。该示例不适用于不能建立 32 位包的 ia64。</phrase>
  </para>

  <procedure>
   <step performance="required">
    <para>
     使用 32 位编译器：
    </para>
<screen>CC="gcc -m32"</screen>
   </step>
   <step performance="required">
    <para>
     指示链接器处理 32 位对象（始终使用 <command>gcc</command> 作为链接器前端）：
    </para>
<screen>LD="gcc -m32"</screen>
   </step>
   <step performance="required">
    <para>
     设置组装器生成 32 位对象：
    </para>
<screen>AS="gcc -c -m32"</screen>
   </step>
   <step performance="required">
    <para>
     指定链接器标志，如 32 位库的位置，例如：
    </para>
<screen>LDFLAGS="-L/usr/lib"</screen>
   </step>
   <step performance="required">
    <para>
     指定 32 位对象代码库的位置：
    </para>
<screen>--libdir=/usr/lib</screen>
   </step>
   <step performance="required">
    <para>
     指定 32 位 X 库的位置：
    </para>
<screen>--x-libraries=/usr/lib</screen>
   </step>
  </procedure>

  <para>
   并不是每个程序都需要这些变量。根据各个程序对这些变量进行调整。
  </para>

  <para os="sles">
   以下是在 x86_64、<phrase os="sles">ppc64 或 System z</phrase> 上编译本机 32 位应用程序的 <command>configure</command> 调用示例：
  </para>

<screen>CC="gcc -m32"
LDFLAGS="-L/usr/lib;"
./configure --prefix=/usr --libdir=/usr/lib --x-libraries=/usr/lib
make
make install</screen>
 </sect1>
 <sect1 id="sec.64bit.kernel">
  <title>内核规范</title><indexterm> <primary>64 位 Linux</primary> <secondary>内核规范</secondary> </indexterm>

  <para>
   x86_64<phrase os="sles">、ppc_64 和 System z</phrase> 的 64 位内核提供 64 位和 32 位内核 ABI（应用程序二进制接口）。后者与对应的 32 位内核的 ABI 相同。这意味着 32 位应用程序可以以与 32 位内核交流的相同方式与 64 位内核进行交流。
  </para>

  <para>
   64 位内核系统调用的 32 位仿真不支持系统程序使用的某些 API。这取决于平台。因此，必须在非 ppc64 平台上将少量应用程序（如 <command>lspci</command>）<phrase os="sles">编译为 64 位程序才能正常工作。在 IBM System z 上，并非所有 ioctl 都在 32 位内核 ABI 中可用</phrase>。
  </para>

  <para>
   64 位内核只能装载专门为此内核编译的 64 位内核模块。不能使用 32 位内核模块。
  </para>

  <tip>
   <title>内核可装载模块</title>
   <para>
    某些应用程序需要单独的内核可装载模块。如果要在 64 位系统环境中使用此类 32 位应用程序，请与此应用程序的提供商和 SUSE 联系以确保内核可装载模块的 64 位版本和内核 API 的 32 位编译版本可用于此模块。
   </para>
  </tip>
 </sect1>
</chapter>
