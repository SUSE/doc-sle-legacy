<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook51-profile.xsl"
    type="text/xml"
    title="Profiling step"
?>
<!DOCTYPE chapter
[
   <!ENTITY % entities SYSTEM "entity-decl.ent">
   %entities;
]>


<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1" xml:id="cha-slert-intro"><title>Introduction</title><info/>
 
 <para>
  In the Linux kernel, the cpuset facility provides a mechanism for creating
  logical entities called <quote>cpusets</quote> that encompass definitions
  of CPUs and NUMA Memory Nodes (if NUMA is available). Cpusets constrain
  the CPU and Memory placement of a task to only the resources defined
  within that cpuset. These cpusets can then be arranged into a nested
  hierarchy visible in the <quote>cpuset</quote> virtual file system. Sets
  of tasks can be assigned to these cpusets to constrain the resources that
  they use. The tasks can be moved from one cpuset to another to utilize
  other resources defined in those other cpusets.
 </para>
 <para>
  The <command>cset</command> command is a Python application that provides
  a command line front end for the Linux cpusets functionality. Working with
  cpusets directly can be confusing and slightly complex. The cset tool
  hides that complexity behind an easy-to-use command line interface.
 </para>
 <para>
  There are two distinct use cases for cset: the basic shielding use case
  and the <quote>advanced</quote> case of using raw set and proc
  subcommands. The basic shielding function is accessed with the shield
  subcommand and described in the next section. Using the raw set and proc
  subcommands allows one to set up arbitrarily complex cpusets and is
  described in the later sections.
 </para>
 <para>
  Note that in general, one either uses the shield subcommand or a
  combination of the set and proc subcommands. One rarely, if ever, uses all
  of these subcommands together. Doing so will likely become too confusing.
  Additionally, the shield subcommand sets up its required cpusets with
  exclusively marked CPUs. This can interfere with your cpuset strategy. If
  you find that you need more functionality for your strategy than shield
  provides, go ahead and transition to using set and proc exclusively. It is
  straightforward to implement what shield does with a few extra set and
  proc subcommands.
 </para>
 <variablelist>
  <title>Obtaining Online Help</title>
  <varlistentry>
   <term>For a full list of cset subcommands</term>
   <listitem>
<screen>&prompt.user;<command>cset</command> <option>help</option></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>For in-depth help on individual subcommands</term>
   <listitem>
<screen>&prompt.user;<command>cset</command> <option>help</option> <replaceable>&lt;subcommand&gt;</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>For options on individual subcommands</term>
   <listitem>
<screen>&prompt.user;<command>cset</command> <replaceable>&lt;subcommand&gt;</replaceable> <option>(-h | --help)</option></screen>
   </listitem>
  </varlistentry>
 </variablelist>
</chapter>
