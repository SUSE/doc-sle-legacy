<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook51-profile.xsl"
    type="text/xml"
    title="Profiling step"
?>
<!DOCTYPE chapter
[
   <!ENTITY % entities SYSTEM "entity-decl.ent">
   %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1" xml:id="cha-qemu-running">
 <title>Running Virtual Machines with qemu-kvm</title>
 <info/>
 <para>
  Once you have a virtual disk image ready (for more information on disk
  images, see <xref linkend="cha-qemu-guest-inst-qemu-img"/>), it is time to
  start the related virtual machine.
  <xref linkend="cha-qemu-guest-inst-qemu-kvm"/> introduced simple commands to
  install and run a &vmguest;. This chapter focuses on a more detailed
  explanation of <command>qemu-kvm</command> usage, and shows solutions of more
  specific tasks. For a complete list of <command>qemu-kvm</command>'s options,
  see its manual page (<command>man 1 qemu-kvm</command>).
 </para>
 <section xml:id="cha-qemu-running-basic">
  <title>Basic <command>qemu-kvm</command> Invocation</title>
  <para>
   The <command>qemu-kvm</command> command uses the following syntax:
  </para>
<screen>qemu-kvm options<co xml:id="co-qemu-running-basic-opts"/> disk_img<co xml:id="co-qemu-running-basic-img"/></screen>
  <calloutlist>
   <callout arearefs="co-qemu-running-basic-opts">
    <para>
     <command>qemu-kvm</command> understands a large number of options. Most of
     them define parameters of the emulated hardware, while others affect more
     general emulator behavior. If you do not supply any options, default
     values are used, and you need to supply the path to a disk image to be
     run.
    </para>
   </callout>
   <callout arearefs="co-qemu-running-basic-img">
    <para>
     Path to the disk image holding the guest system you want to virtualize.
     <command>qemu-kvm</command> supports a large number of image formats. Use
     <command>qemu-img --help</command> to list them. If you do not supply the
     path to a disk image as a separate argument, you have to use the
     <literal>-drive file=</literal> option.
    </para>
   </callout>
  </calloutlist>
 </section>
 <section xml:id="cha-qemu-running-gen-opts">
  <title>General <command>qemu-kvm</command> Options</title>
  <para>
   This section introduces general <command>qemu-kvm</command> options and
   options related to the basic emulated hardware, such as virtual machine's
   processor, memory, model type, or time processing methods.
  </para>
  <variablelist>
   <varlistentry>
    <term><literal>-name <replaceable>name_of_guest</replaceable></literal></term>
    <listitem>
     <para>
      Specifies the name of the running guest system. The name is displayed in
      the window caption and also used for the VNC server.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-boot <replaceable>options</replaceable></literal></term>
    <listitem>
     <para>
      Specifies the order in which the defined drives will be booted. Drives
      are represented by letters, where 'a' and 'b' stands for the floppy
      drives 1 and 2, 'c' stands for the first hard disk, 'd' stands for the
      first CD-ROM drive, and 'n' to 'p' stand for Ether-boot network adapters.
     </para>
     <para>
      For example, <literal>qemu-kvm [...] -boot order=ndc</literal> first
      tries to boot from network, then from the first CD-ROM drive, and finally
      from the first hard disk.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-pidfile <replaceable>fname</replaceable></literal></term>
    <listitem>
     <para>
      Stores the &qemu;'s process identification number (PID) in a file. This
      is useful if you run &qemu; from a script.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-nodefaults</literal></term>
    <listitem>
     <para>
      By default &qemu; creates basic virtual devices even if you do not
      specify them on the command line. This option turns this feature off, and
      you must specify every single device manually, including graphical and
      network cards, parallel or serial ports, or virtual consoles. Even &qemu;
      monitor is not attached by default.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-daemonize</literal></term>
    <listitem>
     <para>
      'Daemonizes' the &qemu; process after it is started. &qemu; will detach
      from the standard input and standard output after it is ready to receive
      connections on any of its devices.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <section xml:id="cha-qemu-running-gen-opts-basic">
   <title>Basic Virtual Hardware</title>
   <variablelist>
    <varlistentry>
     <term><literal>-M <replaceable>machine_type</replaceable></literal></term>
     <listitem>
      <para>
       Specifies the type of the emulated machine. Run <command>qemu-kvm -M
       help</command> to view a list of supported machine types.
      </para>
<screen>&exampleuser;@&wsII;:~&gt; qemu-kvm -M help
Supported machines are:
q35                  Standard PC (Q35 + ICH9, 2009) (alias of pc-q35-1.4)
pc-q35-1.4           Standard PC (Q35 + ICH9, 2009)
pc                   Standard PC (i440FX + PIIX, 1996) 
pc-i440fx-1.4        Standard PC (i440FX + PIIX, 1996) (default)
pc-1.3               Standard PC
pc-1.2               Standard PC
pc-1.1               Standard PC
pc-1.0               Standard PC
pc-0.15              Standard PC
pc-0.14              Standard PC
pc-0.13              Standard PC
pc-0.12              Standard PC
pc-0.11              Standard PC, qemu 0.11
pc-0.10              Standard PC, qemu 0.10
isapc                ISA-only PC
none                 empty machine</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-m <replaceable>megabytes</replaceable></literal></term>
     <listitem>
      <para>
       Specifies how many megabytes are used for the virtual RAM size. Default
       is 512 MB.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-balloon virtio</literal></term>
     <listitem>
      <para>
       Specifies a paravirtualized device to dynamically change the amount of
       virtual RAM memory assigned to &vmguest;. The top limit is the amount of
       memory specified with <literal>-m</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-cpu <replaceable>cpu_model</replaceable></literal></term>
     <listitem>
      <para>
       Specifies the type of the processor (CPU) model. Run <command>qemu-kvm
       -cpu ?</command> to view a list of supported CPU models.
      </para>
<screen>&exampleuser;@&wsII;:~&gt; qemu-kvm -cpu help
 x86           qemu64  QEMU Virtual CPU version 1.4.0                  
 x86           phenom  AMD Phenom(tm) 9550 Quad-Core Processor         
 x86         core2duo  Intel(R) Core(TM)2 Duo CPU     T7700  @ 2.40GHz 
 x86            kvm64  Common KVM processor                            
 x86           qemu32  QEMU Virtual CPU version 1.4.0                  
 x86            kvm32  Common 32-bit KVM processor                     
 x86          coreduo  Genuine Intel(R) CPU           T2600  @ 2.16GHz 
 x86              486                                                  
 x86          pentium                                                  
 x86         pentium2                                                  
 x86         pentium3                                                  
 x86           athlon  QEMU Virtual CPU version 1.4.0                  
 x86             n270  Intel(R) Atom(TM) CPU N270   @ 1.60GHz          
 x86           Conroe  Intel Celeron_4x0 (Conroe/Merom Class Core 2)   
 x86           Penryn  Intel Core 2 Duo P9xxx (Penryn Class Core 2)    
 x86          Nehalem  Intel Core i7 9xx (Nehalem Class Core i7)       
 x86         Westmere  Westmere E56xx/L56xx/X56xx (Nehalem-C)          
 x86      SandyBridge  Intel Xeon E312xx (Sandy Bridge)                
 x86          Haswell  Intel Core Processor (Haswell)                  
 x86       Opteron_G1  AMD Opteron 240 (Gen 1 Class Opteron)           
 x86       Opteron_G2  AMD Opteron 22xx (Gen 2 Class Opteron)          
 x86       Opteron_G3  AMD Opteron 23xx (Gen 3 Class Opteron)          
 x86       Opteron_G4  AMD Opteron 62xx class CPU                      
x86       Opteron_G5  AMD Opteron 63xx class CPU</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-smp <replaceable>number_of_cpus</replaceable></literal></term>
     <listitem>
      <para>
       Specifies how many CPUs will be emulated. &qemu; supports up to 255 CPUs
       on the PC platform (up to 64 with KVM acceleration used). This option
       also takes other CPU-related parameters, such as number of
       <emphasis>sockets</emphasis>, number of <emphasis>cores</emphasis> per
       socket, or number of <emphasis>threads</emphasis> per core.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Following is an example of a working <command>qemu-kvm</command> command
    line:
   </para>
<screen>qemu-kvm -name "SLES 11 SP1" -M pc-0.12 -m 512 -cpu kvm64 \
-smp 2 /images/sles11sp1.raw</screen>
   <figure>
    <title>&qemu; Window with SLES 11 SP1 as &vmguest;</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <variablelist>
    <varlistentry>
     <term><literal>-no-acpi</literal></term>
     <listitem>
      <para>
       Disables ACPI support. Try to use it if &vmguest; reports problems with
       ACPI interface.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-S</literal></term>
     <listitem>
      <para>
       &qemu; starts with CPU stopped. To start CPU, enter <literal>c</literal>
       in &qemu; monitor. For more information, see
       <xref linkend="cha-qemu-monitor"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </section>
  <section xml:id="cha-qemu-running-gen-opts-storing-cong">
   <title>Storing and Reading Configuration of Virtual Devices</title>
   <variablelist>
    <varlistentry>
     <term><literal>-readconfig <replaceable>cfg_file</replaceable></literal></term>
     <listitem>
      <para>
       Instead of entering the devices configuration options on the command
       line each time you want to run &vmguest;, <command>qemu-kvm</command>
       can read it from a file which was either previously saved with
       <literal>-writeconfig</literal> or edited manually.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-writeconfig <replaceable>cfg_file</replaceable></literal></term>
     <listitem>
      <para>
       Dumps the current virtual machine devices configuration to a text file.
       It can be consequently re-used with the <literal>-readconfig</literal>
       option.
      </para>
<screen>&exampleuser;@&wsII;:~&gt; qemu-kvm -name "SLES 11 SP1" -M pc-0.12 -m 512 -cpu kvm64 \
-smp 2 /images/sles11sp1.raw -writeconfig /images/sles11sp1.cfg
(exited)
&exampleuser;@&wsII;:~&gt; more /images/sles11sp1.cfg
# qemu config file

[drive]
  index = "0"
  media = "disk"
  file = "/images/sles11sp1_base.raw"</screen>
      <para>
       This way you can effectively manage the configuration of your virtual
       machines' devices in a well-arranged way.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </section>
  <section xml:id="cha-qemu-running-gen-opts-rtc">
   <title>Guest Real-time Clock</title>
   <variablelist>
    <varlistentry>
     <term><literal>-rtc <replaceable>options</replaceable></literal></term>
     <listitem>
      <para>
       Specifies the way the RTC is handled inside a &vmguest;. By default, the
       clock of the guest is derived from that of the host system. Therefore,
       it is recommended that the host system clock is synchronized with an
       accurate external clock (for example, via NTP service).
      </para>
      <para>
       If you need to isolate the &vmguest; clock from the host one, specify
       <literal>clock=vm</literal> instead of the default
       <literal>clock=host</literal>.
      </para>
      <para>
       You can also specify a 'starting point' for &vmguest; clock with the
       <literal>base</literal> option:
      </para>
<screen>qemu-kvm [...] -rtc clock=vm,base=2010-12-03T01:02:00</screen>
      <para>
       Instead of a timestamp, you can specify <literal>utc</literal> or
       <literal>localtime</literal>. The former instructs &vmguest; to start at
       the current UTC value (Coordinated Universal Time, see
       <link xlink:href="http://en.wikipedia.org/wiki/UTC"/>), while the latter
       applies the local time setting.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </section>
<!--
  #!/bin/sh
  #set -x
  bridge=br0
  tap=$(/usr/bin/sudo /bin/tunctl -u $(/usr/bin/whoami) -b)

  /usr/bin/sudo /sbin/ip link set $tap up
  sleep 0.5s
  /usr/bin/sudo /sbin/brctl addif $bridge $tap

  /usr/bin/qemu-kvm -m 512 \
  -boot order=cd,menu=on \
  -drive
  file=/local/kvm/sles11-SP1-vnc15.raw,if=virtio,cache=none,aio=native,boot=on \
  -net nic,model=virtio,macaddr=52:54:00:12:45:80 -net
  tap,ifname=$tap,script=no,downscript=no \
  -vga std \
  -usb -usbdevice tablet \
  -balloon virtio \
  -writeconfig /local/kvm/test.cfn \
  -vnc :15 -k de

  /usr/bin/sudo /sbin/brctl delif $bridge $tap
  /usr/bin/sudo /sbin/ip link set $tap down
  /usr/bin/sudo /bin/tunctl -d $tap
  -->
 </section>
 <section xml:id="cha-qemu-running-devices">
  <title>Using Devices in &qemu;</title>
  <para>
   &qemu; virtual machines emulate all devices needed to run a &vmguest;.
   &qemu; supports, for example, several types of network cards, block devices
   (hard and removable drives), <phrase condition="kvm4x86">USB devices,
   </phrase>character devices (serial and parallel
   ports)<phrase condition="kvm4x86">, or multimedia devices (graphic and sound
   cards)</phrase>. For satisfactory operation and performance of the virtual
   machine, some or all of these devices must be configured correctly. This
   section introduces options to configure various types of supported devices.
  </para>
  <tip>
   <para>
    If your device, such as <literal>-drive</literal>, needs a special driver
    and driver properties to be set, specify them with the
    <literal>-device</literal> option, and identify with
    <literal>drive=</literal> suboption. For example
   </para>
<screen>qemu [...] -drive if=none,id=drive0,format=raw \
-device virtio-blk-pci,drive=drive0,scsi=off ...</screen>
   <para>
    To get help on available drivers and their properties, use <option>-device
    ?</option> and <option>-device
    <replaceable>driver</replaceable>,?</option>.
   </para>
  </tip>
  <section xml:id="cha-qemu-running-devices-block">
   <title>Block Devices</title>
   <para>
    Block devices are vital for virtual machines. In general, these are fixed
    or removable storage media usually referred to as 'drives'. One of the
    connected hard drives typically holds the guest operating system to be
    virtualized.
   </para>
   <para>
    Virtual machine drives are defined with <literal>-drive</literal>. This
    option uses many suboptions, some of which are described in this section.
    For their complete list, see the manual page (<literal>man 1
    qemu-kvm</literal>).
   </para>
   <variablelist>
    <title>Sub-options for the <literal>-drive</literal> Option</title>
    <varlistentry>
     <term><literal>file=image_fname</literal></term>
     <listitem>
      <para>
       Specifies the path to the disk image which will be used with this drive.
       If not specified, an empty (removable) drive is assumed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>if=drive_interface</literal></term>
     <listitem>
      <para>
       Specifies the type of interface to which the drive is connected.
       Currently only <literal>floppy</literal>, <literal>ide</literal>, or
       <literal>virtio</literal> are supported by &suse;.
       <literal>virtio</literal> defines a paravirtualized disk driver. Default
       is <literal>ide</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>index=index_of_connector</literal></term>
     <listitem>
      <para>
       Specifies the index number of a connector on the disk interface (see the
       <literal>if</literal> option) where the drive is connected. If not
       specified, the index is automatically incremented.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>media=type</literal></term>
     <listitem>
      <para>
       Specifies the type of the media. Can be <literal>disk</literal> for hard
       disks, or <literal>cdrom</literal> for removable CD-ROM drives.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>format=img_fmt</literal></term>
     <listitem>
      <para>
       Specifies the format of the connected disk image. If not specified, the
       format is autodetected. Currently, &suse; supports
       <literal>qcow2</literal>, <literal>qed</literal> and
       <literal>raw</literal> formats for read and write access. The
       <literal>vmdk</literal>, <literal>vpc</literal> and
       <literal>vhd</literal>/<literal>vhdx</literal> formats are only
       supported in read-only mode.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>cache=method</literal></term>
     <listitem>
      <para>
       Specifies the caching method for the drive. Possible values are
       <literal>unsafe</literal>, <literal>writethrough</literal>,
       <literal>writeback</literal>, <literal>directsync</literal>, or
       <literal>none</literal>. For the <literal>qcow2</literal> image format,
       choose <literal>writeback</literal> if you care about performance.
       <literal>none</literal> disables the host page cache and, therefore, is
       the safest option. Default for image files is
       <literal>writeback</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <tip>
    <para>
     To simplify defining of block devices, &qemu; understands several
     shortcuts which you may find handy when entering the
     <literal>qemu-kvm</literal> command line.
    </para>
    <para>
     You can use
    </para>
<screen>qemu-kvm -cdrom /images/cdrom.iso</screen>
    <para>
     instead of
    </para>
<screen>qemu-kvm -drive file=/images/cdrom.iso,index=2,media=cdrom</screen>
    <para>
     and
    </para>
<screen>qemu-kvm -hda /images/imagei1.raw -hdb /images/image2.raw -hdc \
/images/image3.raw -hdd /images/image4.raw</screen>
    <para>
     instead of
    </para>
<screen>qemu-kvm -drive file=/images/image1.raw,index=0,media=disk \
-drive file=/images/image2.raw,index=1,media=disk \
-drive file=/images/image3.raw,index=2,media=disk \
-drive file=/images/image4.raw,index=3,media=disk</screen>
   </tip>
   <tip>
    <title>Using Host Drives Instead of Images</title>
    <para>
     Normally you will use disk images (see
     <xref linkend="cha-qemu-guest-inst-qemu-img"/>) as disk drives of the
     virtual machine. However, you can also use existing &vmhost; disks,
     connect them as drives, and access them from &vmguest;. Use the host disk
     device directly instead of disk image filenames.
    </para>
    <para>
     To access the host CD-ROM drive, use
    </para>
<screen>qemu-kvm [...] -drive file=/dev/cdrom,media=cdrom</screen>
    <para>
     To access the host hard disk, use
    </para>
<screen>qemu-kvm [...] -drive file=/dev/hdb,media=disk</screen>
    <para>
     When accessing the host hard drive from &vmguest;, always make sure the
     access is <emphasis>read-only</emphasis>. You can do so by modifying the
     host device permissions.
    </para>
   </tip>
   <section>
    <title>virtio-blk-data-plane</title>
    <para>
     The <emphasis>virtio-blk-data-plane</emphasis> is a new performance
     feature for KVM. It enables a high-performance code path for I/O requests
     coming from &vmguest;s. More specifically, this feature introduces
     dedicated threads (one per virtual block device) to process I/O requests
     going through the <emphasis>virtio-blk</emphasis> driver. It makes use of
     Linux AIO (asynchronous I/O interface) support in the &vmhost; Kernel
     directly&mdash;without the need to go through the QEMU block layer.
     Therefore it can sustain very high I/O rates on storage setups.
    </para>
    <para>
     The virtio-blk-data-plane feature can be enabled or disabled by the
     <option>x-data-plane=on|off</option> option on the <command>qemu</command>
     command line when starting the &vmguest;:
    </para>
<screen>qemu [...] -drive if=none,id=drive0,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive0,scsi=off,\
config-wce=off,x-data-plane=on [...]</screen>
    <para>
     As of now, the virtio-blk-data-plane has the following limitations:
    </para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>
       Only raw image format is supported.
      </para>
     </listitem>
     <listitem>
      <para>
       No support for live migration.
      </para>
     </listitem>
     <listitem>
      <para>
       Block jobs and hot unplug operations fail with -EBUSY.
      </para>
     </listitem>
     <listitem>
      <para>
       I/O throttling limits are ignored.
      </para>
     </listitem>
     <listitem>
      <para>
       Only Linux &vmhost;s are supported because of the Linux AIO usage, but
       non-Linux &vmguest;s are supported.
      </para>
     </listitem>
    </itemizedlist>
    <important>
     <para>
      The virtio-blk-data-plane feature is not yet supported in &productname;.
      It is released as a technical preview only.
     </para>
    </important>
   </section>
  </section>
  <section xml:id="cha-qemu-running-devices-graphic">
   <title>Graphic Devices and Display Options</title>
   <para>
    This section describes &qemu; options affecting the type of the emulated
    video card and the way &vmguest; graphical output is displayed.
   </para>
   <section xml:id="cha-qemu-running-devices-graphic-vga">
    <title>Defining Video Cards</title>
    <para>
     &qemu; uses <literal>-vga</literal> to define a video card used to display
     &vmguest; graphical output. The <literal>-vga</literal> option understands
     the following values:
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>none</literal></term>
      <listitem>
       <para>
        Disables video cards on &vmguest; (no video card is emulated). You can
        still access the running &vmguest; via the &qemu; monitor and the
        serial console.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>std</literal></term>
      <listitem>
       <para>
        Emulates a standard VESA 2.0 VBE video card. Use it if you intend to
        use high display resolution on &vmguest;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>cirrus</literal></term>
      <listitem>
       <para>
        Emulates Cirrus Logic GD5446 video card. Good choice if you insist on
        high compatibility of the emulated video hardware. Most operating
        systems (even Windows 95) recognize this type of card.
       </para>
       <tip>
        <para>
         For best video performance with the <literal>cirrus</literal> type,
         use 16-bit color depth both on &vmguest; and &vmhost;.
        </para>
       </tip>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
   <section xml:id="cha-qemu-running-devices-graphic-display">
    <title>Display Options</title>
    <para>
     The following options affect the way &vmguest; graphical output is
     displayed.
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>-nographic</literal></term>
      <listitem>
       <para>
        Disables &qemu;'s graphical output. The emulated serial port is
        redirected to the console.
       </para>
       <para>
        After starting the virtual machine with <literal>-nographic</literal>,
        press
        <keycombo><keycap function="control"/><keycap>A</keycap></keycombo>
        <keycap>H</keycap> in the virtual console to view the list of other
        useful shortcuts, for example, to toggle between the console and the
        &qemu; monitor.
       </para>
<screen>&exampleuser;@&wsII;:~&gt; qemu-kvm -hda /images/sles11sp1_base.raw -nographic

C-a h    print this help
C-a x    exit emulator
C-a s    save disk data back to file (if -snapshot)
C-a t    toggle console timestamps
C-a b    send break (magic sysrq)
C-a c    switch between console and monitor
C-a C-a  sends C-a
(pressed C-a c)

QEMU 0.12.5 monitor - type 'help' for more information
(qemu)</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-frame</literal></term>
      <listitem>
       <para>
        Disables decorations for the &qemu; window. Convenient for dedicated
        desktop workspace.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-full-screen</literal></term>
      <listitem>
       <para>
        Starts &qemu; graphical output in full screen mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-quit</literal></term>
      <listitem>
       <para>
        Disables the 'close' button of &qemu; window and prevents it from being
        closed by force.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-alt-grab, -ctrl-grab</literal></term>
      <listitem>
       <para>
        By default &qemu; window releases the 'captured' mouse after
        <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap></keycombo> is
        pressed. You can change the key combination to either
        <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Shift</keycap></keycombo>
        (<literal>-alt-grab</literal>), or <keycap>Right Ctrl</keycap>
        (<literal>-ctrl-grab</literal>).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
  </section>
  <section xml:id="cha-qemu-running-devices-usb" condition="kvm4x86">
   <title>USB Devices</title>
   <para>
    There are basically two ways to create USB devices usable by the &vmguest;
    in &kvm;: you can either emulate new USB devices inside a &vmguest;, or
    assign an existing host USB device to a &vmguest;. To use USB devices in
    &qemu; you first need to enable the generic USB driver with the
    <option>-usb</option> option. Then you can specify individual devices with
    the <option>-usbdevice</option> option.
   </para>
   <section xml:id="kvm-usb-emulate">
    <title>Emulating USB Devices in &vmguest;</title>
    <para>
     &suse; currently supports the following types of USB devices:
     <literal>disk</literal>, <literal>host</literal>,
     <literal>serial</literal>, <literal>braille</literal>,
     <literal>net</literal><literal>mouse</literal> and
     <literal>tablet</literal>.
    </para>
    <variablelist>
     <title>Types of USB devices for the <literal>-usbdevice</literal> option</title>
     <varlistentry>
      <term><literal>disk</literal></term>
      <listitem>
       <para>
        Emulates a mass storage device based on file. The optional
        <literal>format</literal> option is used rather than detecting the
        format.
       </para>
<screen>qemu-kvm [...] -usbdevice
        disk:format=raw:/virt/usb_disk.raw</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>host</literal></term>
      <listitem>
       <para>
        Pass through the host device (identified by bus.addr).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>serial</literal></term>
      <listitem>
       <para>
        Serial converter to a host character device.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>braille</literal></term>
      <listitem>
       <para>
        Emulates a braille device using BrlAPI to display the braille output.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>net</literal></term>
      <listitem>
       <para>
        Emulates a network adapter that supports CDC ethernet and RNDIS
        protocols.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>mouse</literal></term>
      <listitem>
       <para>
        Emulates a virtual USB mouse. This option overrides the default PS/2
        mouse emulation. The following example shows the hardware status of a
        mouse on &vmguest; started with <literal>qemu-kvm [...] -usbdevice
        mouse</literal>:
       </para>
<screen>&exampleuser;@&wsII;:~&gt; hwinfo --mouse
20: USB 00.0: 10503 USB Mouse
[Created at usb.122]
UDI: /org/freedesktop/Hal/devices/usb_device_627_1_1_if0
[...]
Hardware Class: mouse
Model: "Adomax QEMU USB Mouse"
Hotplug: USB
Vendor: usb 0x0627 "Adomax Technology Co., Ltd"
Device: usb 0x0001 "QEMU USB Mouse"
[...]</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>tablet</literal></term>
      <listitem>
       <para>
        Emulates a pointer device that uses absolute coordinates (such as
        touchscreen). This option overrides the default PS/2 mouse emulation.
        The tablet device is useful if you are viewing &vmguest; via the VNC
        protocol. See <xref linkend="cha-qemu-running-vnc"/> for more
        information.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
   <section xml:id="kvm-usb-passthru">
    <title>&usbback;</title>
    <para>
     To assign an existing host USB device to a &vmguest;, you need to find out
     its host bus and device ID.
    </para>
<screen>&exampleuser;@vmhost:~&gt; lsusb
[...]
Bus 002 Device 005: ID 12d1:1406 Huawei Technologies Co., Ltd. E1750
[...]</screen>
    <para>
     In the above example, we want to assign a USB stick connected to the
     host's USB bus number 2 with device number 5. Now run the &vmguest; with
     the following additional options:
    </para>
<screen>qemu-kvm [...] -usb -device usb-host,hostbus=2,hostaddr=5</screen>
    <para>
     After the guest is booted, check that the assigned USB device is present
     on it.
    </para>
<screen>&exampleuser;@vmguest:~&gt; lsusb
[...]
Bus 001 Device 002: ID 12d1:1406 Huawei Technologies Co., Ltd. E1750
[...]</screen>
    <note>
     <para>
      The guest operating system must take care of mounting the assigned USB
      device so that it is accessible for the user.
     </para>
    </note>
   </section>
  </section>
  <section xml:id="kvm-pciback" condition="kvm4x86">
   <title>&pciback;</title>
   <para>
    &pciback; is a technique to give your &vmguest; exclusive access to a PCI
    device.
   </para>
   <note>
    <para>
     To make use of &pciback;, your motherboard chipset, BIOS, and CPU must
     have support for AMD's IOMMU (or VT-d in Intel speak) virtualization
     technology. To make sure that your computer supports this feature, ask
     your supplier specifically to deliver a system that supports &pciback;.
    </para>
   </note>
   <note>
    <para>
     Assignment of graphics cards is not supported by &suse;.
    </para>
   </note>
   <procedure>
    <title>Configuring &pciback;</title>
    <step>
     <para>
      Make sure that <literal>CONFIG_DMAR_DEFAULT_ON</literal> is set in the
      host's running Kernel:
     </para>
<screen>grep CONFIG_DMAR_DEFAULT_ON /boot/config-`uname -r`</screen>
     <para>
      If this option is not set, edit your boot loader configuration and add
      <literal>intel_iommu=on</literal> (Intel machines) or <literal>iommu=pt
      iommu=1</literal> (AMD machines). Then reboot the host machine.
     </para>
    </step>
    <step>
     <para>
      Check that IOMMU is actively enabled and recognized on the host. Run
      <command>dmesg | grep -e DMAR -e IOMMU</command> on Intel machines, or
      <command>dmesg | grep AMD-Vi</command> on AMD machines. If you get no
      output, check carefully if your hardware supports IOMMU (VT-d) and check
      that it has been enabled in BIOS.
     </para>
    </step>
    <step>
     <para>
      Identify the host PCI device to assign to the guest.
     </para>
<screen>&exampleuser;@vmhost:~&gt; lspci -nn
[...] 00:1b.0 Audio device [0403]: Intel Corporation 82801H (ICH8 Family) \
HD Audio Controller [8086:284b] (rev 02) [...]</screen>
     <para>
      Note down the device (<literal>00:1b.0</literal>) and vendor
      (<literal>8086:284b</literal>) ID.
     </para>
    </step>
    <step>
     <para>
      Unbind the device from host Kernel driver and bind it to the PCI stub
      driver.
     </para>
<screen>&exampleuser;@vmhost:~&gt; modprobe pci_stub
&exampleuser;@vmhost:~&gt; echo "8086 284b" &gt; /sys/bus/pci/drivers/pci-stub/new_id
&exampleuser;@vmhost:~&gt; echo "0000:00:1b.0" &gt; /sys/bus/pci/devices/0000:00:1b.0/driver/unbind
&exampleuser;@vmhost:~&gt; echo "0000:00:1b.0" &gt; /sys/bus/pci/drivers/pci-stub/bind</screen>
    </step>
    <step>
     <para>
      Now run the &vmguest; with the PCI device assigned.
     </para>
<screen>qemu-kvm [...] -device pci-assign,host=00:1b.0</screen>
    </step>
   </procedure>
   <note>
    <para>
     If the PCI device shares IRQ with other devices, it cannot be assigned to
     a &vmguest;.
    </para>
   </note>
   <para>
    &kvm; also supports PCI device hot-plugging to a &vmguest;. To achieve
    this, you need to switch to a &qemu; monitor (see
    <xref linkend="cha-qemu-monitor"/> for more information) and issue the
    following commands:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      hot add:
     </para>
<screen>device_add pci-assign,host=00:1b.0,id=new_pci_device</screen>
    </listitem>
    <listitem>
     <para>
      hot remove:
     </para>
<screen>device_del new_pci_device</screen>
    </listitem>
   </itemizedlist>
  </section>
  <section xml:id="cha-qemu-running-devices-char">
   <title>Character Devices</title>
   <para>
    Use <literal>-chardev</literal> to create a new character device. The
    option uses the following general syntax:
   </para>
<screen>qemu-kvm [...] -chardev <replaceable>backend_type</replaceable>,id=<replaceable>id_string</replaceable></screen>
   <para>
    where <replaceable>backend_type</replaceable> can be one of
    <literal>null</literal>, <literal>socket</literal>, <literal>udp</literal>,
    <literal>msmouse</literal>, <literal>vc</literal>, <literal>file</literal>,
    <literal>pipe</literal>, <literal>console</literal>,
    <literal>serial</literal>, <literal>pty</literal>,
    <literal>stdio</literal>, <literal>braille</literal>,
    <literal>tty</literal>, or <literal>parport</literal>. All character
    devices must have a unique identification string up to 127 characters long.
    It is used to identify the device in other related directives. For the
    complete description of all back-end's suboptions, see the manual page
    (<command>man 1 qemu-kvm</command>). A brief description of the available
    <literal>back-ends</literal> follows:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>null</literal></term>
     <listitem>
      <para>
       Creates an empty device which outputs no data and drops any data it
       receives.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>stdio</literal></term>
     <listitem>
      <para>
       Connects to &qemu;'s process standard input and standard output.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>socket</literal></term>
     <listitem>
      <para>
       Creates a two-way stream socket. If <replaceable>path</replaceable> is
       specified, a Unix socket is created:
      </para>
<screen>qemu-kvm [...] -chardev \
socket,id=unix_socket1,path=/tmp/unix_socket1,server</screen>
      <para>
       The <replaceable>server</replaceable> suboption specifies that the
       socket is a listening socket.
      </para>
      <para>
       If <replaceable>port</replaceable> is specified, a TCP socket is
       created:
      </para>
<screen>qemu-kvm [...] -chardev \
socket,id=tcp_socket1,host=localhost,port=7777,server,nowait</screen>
      <para>
       The command creates a local listening (<literal>server</literal>) TCP
       socket on port 7777. &qemu; will not block waiting for a client to
       connect to the listening port (<literal>nowait</literal>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>udp</literal></term>
     <listitem>
      <para>
       Sends all network traffic from &vmguest; to a remote host over the UDP
       protocol.
      </para>
<screen>qemu-kvm [...] -chardev udp,id=udp_fwd,host=&wsIVname;,port=7777</screen>
      <para>
       The command binds port 7777 on the remote host &wsIVname; and sends
       &vmguest; network traffic there.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>vc</literal></term>
     <listitem>
      <para>
       Creates a new &qemu; text console. You can optionally specify the
       dimensions of the virtual console:
      </para>
<screen>qemu-kvm [...] -chardev vc,id=vc1,width=640,height=480 -mon chardev=vc1</screen>
      <para>
       The command creates a new virtual console called <literal>vc1</literal>
       of the specified size, and connects the &qemu; monitor to it.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>file</literal></term>
     <listitem>
      <para>
       Logs all traffic from &vmguest; to a file on &vmhost;. The
       <literal>path</literal> is required and will be created if it does not
       exist.
      </para>
<screen>qemu-kvm [...] -chardev file,id=qemu_log1,path=/var/log/qemu/guest1.log</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    By default &qemu; creates a set of character devices for serial and
    parallel ports, and a special console for &qemu; monitor. You can, however,
    create your own character devices and use them for just mentioned purposes.
    The following options will help you:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>-serial <replaceable>char_dev</replaceable></literal></term>
     <listitem>
      <para>
       Redirects the &vmguest;'s virtual serial port to a character device
       <replaceable>char_dev</replaceable> on &vmhost;. By default, it is a
       virtual console (<literal>vc</literal>) in graphical mode, and
       <literal>stdio</literal> in non-graphical mode. The
       <literal>-serial</literal> understands many suboptions. See the manual
       page <command>man 1 qemu-kvm</command> for their complete list.
      </para>
      <para>
       You can emulate up to 4 serial ports. Use <literal>-serial
       none</literal> to disable all serial ports.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-parallel <replaceable>device</replaceable></literal></term>
     <listitem>
      <para>
       Redirects the &vmguest;'s parallel port to a
       <replaceable>device</replaceable>. This option supports the same devices
       as <literal>-serial</literal>.
      </para>
      <tip>
       <para>
        With <phrase os="osuse">&opensuse; or</phrase> &sls; as a &vmhost;, you
        can directly use the hardware parallel port devices
        <filename>/dev/parportN</filename> where <literal>N</literal> is the
        number of the port.
       </para>
      </tip>
      <para>
       You can emulate up to 3 parallel ports. Use <literal>-parallel
       none</literal> to disable all parallel ports.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-monitor <replaceable>char_dev</replaceable></literal></term>
     <listitem>
      <para>
       Redirects the &qemu; monitor to a character device
       <replaceable>char_dev</replaceable> on &vmhost;. This option supports
       the same devices as <literal>-serial</literal>. By default, it is a
       virtual console (<literal>vc</literal>) in a graphical mode, and
       <literal>stdio</literal> in non-graphical mode.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    For a complete list of available character devices back-ends, see the man
    page (<command>man 1 qemu-kvm</command>).
   </para>
  </section>
 </section>
 <section xml:id="cha-qemu-running-networking">
  <title>Networking in &qemu;</title>
  <para>
   Use the <literal>-net</literal> option to define a network interface and a
   specific type of networking for your &vmguest;. Currently, &suse; supports
   the following options: <literal>none</literal>, <literal>nic</literal>,
   <literal>user</literal>, <literal>bridge</literal>, and
   <literal>tap</literal>. For a complete list of <literal>-net</literal>
   suboptions, see the manual page (<command>man 1 qemu-kvm</command>).
  </para>
  <variablelist>
   <title>Supported <literal>-net</literal> Suboptions</title>
   <varlistentry>
    <term><literal>none</literal></term>
    <listitem>
     <para>
      Disables a network card emulation on &vmguest;. Only the loopback
      <literal>lo</literal> network interface is available.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>bridge</literal></term>
    <listitem>
     <para>
      Uses a specified network helper to configure the TAP interface and attach
      it to a specified bridge. For more information, see
      <xref linkend="cha-qemu-running-networking-bridge"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>nic</literal></term>
    <listitem>
     <para>
      Creates a new Network Interface Card (NIC) and connects it to a specified
      Virtual Local Area Network (VLAN). For more information, see
      <xref linkend="cha-qemu-running-networking-nic"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>user</literal></term>
    <listitem>
     <para>
      Specifies a user-mode networking. For more information, see
      <xref linkend="cha-qemu-running-networking-usermode"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tap</literal></term>
    <listitem>
     <para>
      Specifies a bridged or routed networking. For more information, see
      <xref linkend="cha-qemu-running-networking-bridge"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <section xml:id="cha-qemu-running-networking-nic">
   <title>Defining a Network Interface Card</title>
   <para>
    Use <literal>-net nic</literal> to add a new emulated network card:
   </para>
<screen>qemu-kvm [...] -net nic,vlan=1<co xml:id="co-qemu-running-networking-nic-vlan"/>,macaddr=&wsIVmac;<co xml:id="co-qemu-running-networking-nic-mac"/>,\
model=virtio<co xml:id="co-qemu-running-networking-nic-model"/>,name=ncard1<co xml:id="co-qemu-running-networking-nic-name"/></screen>
   <calloutlist>
    <callout arearefs="co-qemu-running-networking-nic-vlan">
     <para>
      Connects the network interface to VLAN number 1. You can specify your own
      number, it is mainly useful for identification purpose. If you omit this
      suboption, &qemu; uses the default 0.
     </para>
    </callout>
    <callout arearefs="co-qemu-running-networking-nic-mac">
     <para>
      Specifies the Media Access Control (MAC) address for the network card. It
      is a unique identifier and you are advised to always specify it. If not,
      &qemu; supplies its own default MAC address and creates a possible MAC
      address conflict within the related VLAN.
     </para>
    </callout>
    <callout arearefs="co-qemu-running-networking-nic-model">
     <para>
      Specifies the model of the network card. Use <literal>-net
      nic,model=?</literal> to get the list of all network card models
      supported by &qemu; on your platform:
     </para>
     <para>
      Currently, &suse; supports the models <literal>rtl8139</literal> and
      <literal>virtio</literal>.
     </para>
    </callout>
   </calloutlist>
  </section>
  <section xml:id="cha-qemu-running-networking-usermode">
   <title>User-mode Networking</title>
   <para>
    The <literal>-net user</literal> option instructs &qemu; to use a user-mode
    networking. This is the default if no networking mode is selected.
    Therefore, these command lines are equivalent:
   </para>
<screen>qemu-kvm -hda /images/sles11sp1_base.raw</screen>
<screen>qemu-kvm -hda /images/sles11sp1_base.raw -net nic -net user</screen>
   <para>
    This mode is useful if you want to allow the &vmguest; to access the
    external network resources, such as Internet. By default, no incoming
    traffic is permitted and therefore, the &vmguest; is not visible to other
    machines on the network. No administrator privileges are required in this
    networking mode. The user-mode is also useful to do a 'network-booting' on
    your &vmguest; from a local directory on &vmhost;.
   </para>
   <para>
    The &vmguest; allocates an IP address from a virtual DHCP server. &vmhost;
    (the DHCP server) is reachable at 10.0.2.2, while the IP address range for
    allocation starts from 10.0.2.15. You can use <command>ssh</command> to
    connect to &vmhost; at 10.0.2.2, and <command>scp</command> to copy files
    back and forth.
   </para>
   <section xml:id="cha-qemu-running-networking-usermode-examples">
    <title>Command Line Examples</title>
    <para>
     This section shows several examples on how to set up user-mode networking
     with &qemu;.
    </para>
    <example xml:id="ex-qemu-net-usermode-resctrict">
     <title>Restricted User-mode Networking</title>
<screen>qemu-kvm [...] -net user<co xml:id="co-usermode-user"/>,vlan=1<co xml:id="co-usermode-vlan"/>,name=user_net1<co xml:id="co-usermode-name"/>,restrict=yes<co xml:id="co-usermode-restrict"/></screen>
     <calloutlist>
      <callout arearefs="co-usermode-user">
       <para>
        Specifies user-mode networking.
       </para>
      </callout>
      <callout arearefs="co-usermode-vlan">
       <para>
        Connect to VLAN number 1. If omitted, defaults to 0.
       </para>
      </callout>
      <callout arearefs="co-usermode-name">
       <para>
        Specifies a human readable name of the network stack. Useful when
        identifying it in the &qemu; monitor.
       </para>
      </callout>
      <callout arearefs="co-usermode-restrict">
       <para>
        Isolates &vmguest;. It will not be able to communicate with &vmhost;
        and no network packets will be routed to the external network.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example xml:id="ex-qemu-net-usermode-iprange">
     <title>User-mode Networking with Custom IP Range</title>
<screen>qemu-kvm [...] -net user,net=10.2.0.0/8<co xml:id="co-usermode-net"/>,host=10.2.0.6<co xml:id="co-usermode-host"/>,dhcpstart=10.2.0.20<co xml:id="co-usermode-dhcpstart"/>,\
hostname=tux_kvm_guest<co xml:id="co-usermode-hostname"/></screen>
     <calloutlist>
      <callout arearefs="co-usermode-net">
       <para>
        Specifies the IP address of the network that &vmguest; sees and
        optionally the netmask. Default is 10.0.2.0/8.
       </para>
      </callout>
      <callout arearefs="co-usermode-host">
       <para>
        Specifies the &vmhost; IP address that &vmguest; sees. Default is
        10.0.2.2.
       </para>
      </callout>
      <callout arearefs="co-usermode-dhcpstart">
       <para>
        Specifies the first of the 16 IP addresses that the built-in DHCP
        server can assign to &vmguest;. Default is 10.0.2.15.
       </para>
      </callout>
      <callout arearefs="co-usermode-hostname">
       <para>
        Specifies the hostname that the built-in DHCP server will assign to
        &vmguest;.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example xml:id="ex-qemu-net-usermode-netboot-tftp">
     <title>User-mode Networking with Network-boot and TFTP</title>
<screen>qemu-kvm [...] -net user,tftp=/images/tftp_dir<co xml:id="co-usermode-tftp"/>,bootfile=/images/boot/pxelinux.0<co xml:id="co-usermode-bootfile"/></screen>
     <calloutlist>
      <callout arearefs="co-usermode-tftp">
       <para>
        Activates a built-in TFTP (a file transfer protocol with the
        functionality of a very basic FTP) server. The files in the specified
        directory will be visible to a &vmguest; as the root of a TFTP server.
       </para>
      </callout>
      <callout arearefs="co-usermode-bootfile">
       <para>
        Broadcasts the specified file as a BOOTP (a network protocol which
        offers an IP address and a network location of a boot image, often used
        in diskless workstations) file. When used together with
        <literal>tftp</literal>, the &vmguest; can boot from network from the
        local directory on the host.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example xml:id="ex-qemu-net-usermode-hostfwd">
     <title>User-mode Networking with Host Port Forwarding</title>
<screen>qemu-kvm [...] -net user,hostfwd=tcp::2222-:22</screen>
     <para>
      Forwards incoming TCP connections to the port 2222 on the host to the
      port 22 (<systemitem class="service">SSH</systemitem>) on &vmguest;. If
      <systemitem class="daemon">sshd</systemitem> is running on &vmguest;,
      enter
     </para>
<screen>ssh qemu_host -p 2222</screen>
     <para>
      where <literal>qemu_host</literal> is the hostname or IP address of the
      host system, to get a <systemitem class="daemon">SSH</systemitem> prompt
      from &vmguest;.
     </para>
    </example>
   </section>
  </section>
  <section xml:id="cha-qemu-running-networking-bridge">
   <title>Bridged Networking</title>
   <para>
    With the <literal>-net tap</literal> option, &qemu; creates a network
    bridge by connecting the host TAP network device to a specified VLAN of
    &vmguest;. Its network interface is then visible to the rest of the
    network. This method does not work by default and has to be explicitly
    specified.
   </para>
   <para>
    First, create a network bridge and add a &vmhost; physical network
    interface (usually <literal>eth0</literal>) to it:
   </para>
   <procedure>
    <step>
     <para>
      Start &yastcc; and select <menuchoice><guimenu>Network
      Devices</guimenu><guimenu>Network Settings</guimenu></menuchoice>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>Add</guimenu> and select <guimenu>Bridge</guimenu> from
      the <guimenu>Device Type</guimenu> drop-down list in the
      <guimenu>Hardware Dialog</guimenu> window. Click <guimenu>Next</guimenu>.
     </para>
    </step>
    <step>
     <para>
      Choose whether you need a dynamically or statically assigned IP address,
      and fill the related network settings if applicable.
     </para>
    </step>
    <step>
     <para>
      In the <guimenu>Bridged Devices</guimenu> pane, select the Ethernet
      device to add to the bridge.
     </para>
     <figure>
      <title>Configuring Network Bridge with &yast;</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
       </imageobject>
      </mediaobject>
     </figure>
     <para>
      Click <guimenu>Next</guimenu>. When asked about adapting an already
      configured device, click <guimenu>Continue</guimenu>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>OK</guimenu> to apply the changes. Check if the bridge is
      created:
     </para>
<screen>&exampleuser;@&wsII;:~&gt; brctl show
bridge name bridge id          STP enabled  interfaces
br0         8000.001676d670e4  no           eth0</screen>
    </step>
   </procedure>
   <section>
    <title>Connecting to a Bridge Manually</title>
    <para>
     Use the following example script to connect &vmguest; to the newly created
     bridge interface <literal>br0</literal>. Several commands in the script
     are run via the <command>sudo</command> mechanism because they require
     &rootuser; privileges.
    </para>
    <note>
     <para>
      Make sure the <systemitem>tunctl</systemitem> and
      <systemitem>bridge-utils</systemitem> packages are installed on the
      &vmhost;. If not, install them with <command>zypper in tunctl
      bridge-utils</command>.
     </para>
    </note>
<screen>
#!/bin/bash
bridge=br0<co xml:id="co-qemu-net-bridge-br"/>
tap=$(sudo tunctl -u $(whoami) -b)<co xml:id="co-qemu-net-bridge-tap"/>
sudo ip link set $tap up<co xml:id="co-qemu-net-bridge-up"/>
sleep 1s<co xml:id="co-qemu-net-bridge-sleep"/>
sudo brctl addif $bridge $tap<co xml:id="co-qemu-net-bridge-br3"/>
qemu-kvm -m 512 -hda /images/sles11sp1_base.raw \
-net nic,vlan=0,model=virtio,macaddr=&wsIVmac; \
-net tap,vlan=0,ifname=$tap<co xml:id="co-qemu-net-bridge-ifname"/>,script=no<co xml:id="co-qemu-net-bridge-script"/>,downscript=no
sudo brctl delif $bridge $tap<co xml:id="co-qemu-net-bridge-delif"/>
sudo ip link set $tap down<co xml:id="co-qemu-net-bridge-linkdown"/>
sudo tunctl -d $tap<co xml:id="co-qemu-net-bridge-deltap"/></screen>
    <calloutlist>
     <callout arearefs="co-qemu-net-bridge-br">
      <para>
       Name of the bridge device.
      </para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-tap">
      <para>
       Prepare a new TAP device and assign it to the user who runs the script.
       TAP devices are virtual network devices often used for virtualization
       and emulation setups.
      </para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-up">
      <para>
       Bring up the newly created TAP network interface.
      </para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-sleep">
      <para>
       Make a 1 second pause to make sure the new TAP network interface is
       really up.
      </para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-br3">
      <para>
       Add the new <literal>TAP</literal> device to the network bridge
       <literal>br0</literal>.
      </para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-ifname">
      <para>
       The <literal>ifname=</literal> suboption specifies the name of the TAP
       network interface used for bridging.
      </para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-script">
      <para>
       Before <command>qemu-kvm</command> connects to a network bridge, it
       checks the <literal>script</literal> and <literal>downscript</literal>
       values. If it finds the specified scripts on the &vmhost; file system,
       it runs the <literal>script</literal> before it connects to the network
       bridge and <literal>downscript</literal> after it exits the network
       environment. You can use these scripts to first set up and bring up the
       bridged network devices, and then to deconfigure them. By default,
       <filename>/etc/qemu-ifup</filename> and
       <filename>/etc/qemu-ifdown</filename> are examined. If
       <literal>script=no</literal> and <literal>downscript=no</literal> are
       specified, the script execution is disabled and you have to take care
       manually.
      </para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-delif">
      <para>
       Deletes the TAP interface from a network bridge <literal>br0</literal>.
      </para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-linkdown">
      <para>
       Sets the state of the TAP device to 'down'.
      </para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-deltap">
      <para>
       Deconfigures the TAP device.
      </para>
     </callout>
    </calloutlist>
   </section>
   <section xml:id="qemu-bridge-helper">
    <title>Connecting to a Bridge with qemu-bridge-helper</title>
    <para>
     Another way to connect &vmguest; to a network through a network bridge is
     by means of the <filename>qemu-bridge-helper</filename> helper program. It
     configures the TAP interface for you, and attaches it to the specified
     bridge. The default helper executable is
     <filename>/usr/lib64/qemu-bridge-helper</filename>. The helper executable
     is setuid root, which is only executable by the members of the
     virtualization group (<literal>kvm</literal>). Therefore the
     <command>qemu-kvm</command> command itself does not have to be run under
     &rootuser; privileges.
    </para>
    <para>
     You can call the helper the following way:
    </para>
<screen>qemu-kvm [...] -net nic,vlan=0,model=virtio -net bridge,vlan=0,br=br0</screen>
    <para>
     You can specify your own custom helper script that will take care of the
     TAP device (de)configuration, with the
     <option>helper=/path/to/your/helper</option> option:
    </para>
<screen>qemu-kvm [...] -net bridge,vlan=0,br=br1,helper=/path/to/bridge-helper</screen>
    <tip>
     <para>
      To define access privileges to <literal>qemu-bridge-helper</literal>,
      inspect the <filename>/etc/qemu-kvm/bridge.conf</filename> file. For
      example the following directive
     </para>
<screen>allow br0</screen>
     <para>
      allows the <command>qemu-kvm</command> command to connect its &vmguest;
      to the network bridge <literal>br0</literal>.
     </para>
    </tip>
   </section>
  </section>
  <section xml:id="kvm-qemu-vnet">
   <title>Accelerated Networking with <systemitem>vhost-net</systemitem></title>
   <para>
    The <systemitem>vhost-net</systemitem> module is used to accelerate &kvm;'s
    paravirtualized network drivers. It provides better latency and greater
    throughput for network.
   </para>
   <para>
    To make use of the module, verify that the host's running Kernel has
    <literal>CONFIG_VHOST_NET</literal> turned on or enabled as a module:
   </para>
<screen>grep CONFIG_VHOST_NET /boot/config-`uname -r`</screen>
   <para>
    Also verify that the guest's running Kernel has
    <literal>CONFIG_PCI_MSI</literal> enabled:
   </para>
<screen>grep CONFIG_PCI_MSI /boot/config-`uname -r`</screen>
   <para>
    If both conditions are met, use the <literal>vhost-net</literal> driver by
    starting the guest with the following example command line:
   </para>
<screen>qemu-kvm [...] -netdev tap,id=guest0,vhost=on,script=no
-net nic,model=virtio,netdev=guest0,macaddr=00:16:35:AF:94:4B</screen>
   <para>
    Note that <literal>guest0</literal> is an identification string of the
    vhost-driven device.
   </para>
  </section>
 </section>
 <section xml:id="cha-qemu-running-vnc">
  <title>Viewing a &vmguest; with&nbsp;VNC</title>
  <para>
   &qemu; normally uses an SDL (a cross-platform multimedia library) window to
   display the graphical output of a &vmguest;. With the
   <literal>-vnc</literal> option specified, you can make &qemu; listen on a
   specified VNC display and redirect its graphical output to the VNC session.
  </para>
  <tip>
   <para>
    When working with &qemu;'s virtual machine via VNC session, it is useful to
    work with the <literal>-usbdevice tablet</literal> option.
   </para>
   <para>
    Moreover, if you need to use another keyboard layout than the default
    <literal>en-us</literal>, specify it with the <literal>-k</literal> option.
   </para>
  </tip>
  <para>
   The first suboption of <literal>-vnc</literal> must be a
   <emphasis>display</emphasis> value. The <literal>-vnc</literal> option
   understands the following display specifications:
  </para>
  <variablelist>
   <varlistentry>
    <term><literal>host:display</literal></term>
    <listitem>
     <para>
      Only connections from <literal>host</literal> on the display number
      <literal>display</literal> will be accepted. The TCP port on which the
      VNC session is then running is normally a 5900 +
      <literal>display</literal> number. If you do not specify
      <literal>host</literal>, connections will be accepted from any host.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>unix:path</literal></term>
    <listitem>
     <para>
      The VNC server listens for connections on Unix domain sockets. The
      <literal>path</literal> option specifies the location of the related Unix
      socket.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>none</literal></term>
    <listitem>
     <para>
      The VNC server functionality is initialized, but the server itself is not
      started. You can start the VNC server later with the &qemu; monitor. For
      more information, see <xref linkend="cha-qemu-monitor"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
<screen>&exampleuser;@&wsII;:~&gt; qemu-kvm [...] -vnc :5
(on the client:)
&exampleuserII;@&wsI;:~&gt; vinagre &wsII;:5905 &amp;</screen>
  <figure>
   <title>&qemu; VNC Session</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>
  <section xml:id="cha-qemu-running-vnc-secure">
   <title>Secure VNC Connections</title>
   <para>
    The default VNC server setup does not use any form of authentication. In
    the previous example, any user can connect and view the &qemu; VNC Session
    from any host on the network.
   </para>
   <para>
    There are several levels of security which you can apply to your VNC
    client/server connection. You can either protect your connection with a
    password, use x509 certificates, use SASL authentication, or even combine
    some of these authentication methods in one &qemu; command.
   </para>
   <para>
    See <xref linkend="app-kvm-certificates"/> for more information about the
    x509 certificates generation. For more information about configuring x509
    certificates on a &vmhost; and the client, see
    <xref linkend="sec-libvirt-connect-remote-tls"/> and
    <xref linkend="sec-libvirt-connect-remote-tls-client"/>.
   </para>
   <para>
    The Vinagre VNC viewer supports advanced authentication mechanisms.
    Therefore, it will be used to view the graphical output of &vmguest; in the
    following examples. For this example, let us assume that the server x509
    certificates <filename>ca-cert.pem</filename>,
    <filename>server-cert.pem</filename>, and
    <filename>server-key.pem</filename> are located in the
    <filename>/etc/pki/qemu</filename> directory on the host, while the
    client's certificates are distributed in the following locations on the
    client:
   </para>
   <simplelist><member><filename>/etc/pki/CA/cacert.pem</filename></member><member><filename>/etc/pki/libvirt-vnc/clientcert.pem</filename></member><member><filename>/etc/pki/libvirt-vnc/private/clientkey.pem</filename></member>
   </simplelist>
   <example xml:id="ex-running-vnc-secure-pwd">
    <title>Password Authentication</title>
<screen>qemu-kvm [...] -vnc :5,password -monitor stdio</screen>
    <para>
     Starts the &vmguest; graphical output on VNC display number 5 (usually
     port 5905). The <literal>password</literal> suboption initializes a simple
     password-based authentication method. There is no password set by default
     and you have to set one with the <command>change vnc password</command>
     command in &qemu; monitor:
    </para>
<screen>QEMU 0.12.5 monitor - type 'help' for more information
(qemu) change vnc password
Password: ****
</screen>
    <para>
     You need the <literal>-monitor stdio</literal> option here, because you
     would not be able to manage the &qemu; monitor without redirecting its
     input/output.
    </para>
   </example>
   <figure>
    <title>Authentication Dialog in Vinagre</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <example xml:id="ex-running-vnc-secure-x509">
    <title>x509 Certificate Authentication</title>
    <para>
     The &qemu; VNC server can use TLS encryption for the session and x509
     certificates for authentication. The server asks the client for a
     certificate and validates it against the CA certificate. Use this
     authentication type if your company provides an internal certificate
     authority.
    </para>
<screen>qemu-kvm [...] -vnc :5,tls,x509verify=/etc/pki/qemu</screen>
   </example>
   <example xml:id="ex-running-vnc-secure-pwd-x509">
    <title>x509 Certificate and Password Authentication</title>
    <para>
     You can combine the password authentication with TLS encryption and x509
     certificate authentication to create a two-layer authentication model for
     clients. Remember to set the password in the &qemu; monitor after you run
     the following command:
    </para>
<screen>qemu-kvm [...] -vnc :5,password,tls,x509verify=/etc/pki/qemu -monitor stdio</screen>
   </example>
   <example xml:id="ex-running-vnc-secure-sasl">
    <title>SASL Authentication</title>
    <para>
     Simple Authentication and Security Layer (SASL) is a framework for
     authentication and data security in Internet protocols. It integrates
     several authentication mechanisms, like PAM, Kerberos, LDAP and more. SASL
     keeps its own user database, so the connecting user accounts do not need
     to exist on &vmhost;.
    </para>
    <para>
     For security reasons, you are advised to combine SASL authentication with
     TLS encryption and x509 certificates:
    </para>
<screen>qemu-kvm [...] -vnc :5,tls,x509,sasl -monitor stdio</screen>
   </example>
  </section>
 </section>
 <section xml:id="kvm-qemu-virtfs">
  <title>VirtFS: Sharing Folders between Host and Guests</title>
  <para>
   &vmguest;s usually run in a separate computing space&mdash;they are provided
   their own memory range, dedicated CPUs, and file system space. Ability to
   share parts of &vmhost;'s file system makes the virtualization environment
   more flexible by simplifying mutual data exchange. Network file systems,
   such as CIFS and NFS, have been the traditional way of sharing folders. But
   as they are not specifically designed for virtualization purposes, they
   suffer from major performance and feature issues.
  </para>
  <para>
   &kvm; introduces a new and more optimized tool called
   <emphasis>VirtFS</emphasis> (sometimes referred to as a <quote>file system
   pass-through</quote>). VirtFS uses a paravirtual file system driver, which
   avoids converting the guest application file system operations into block
   device operations, and then again into host file system operations. VirtFS
   uses Plan-9 network protocol for communication between the guest and the
   host.
  </para>
  <para>
   You can typically use VirtFS to
  </para>
  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     access a shared folder from several guests, or to provide guest-to-guest
     file system access.
    </para>
   </listitem>
   <listitem>
    <para>
     replace the virtual disk as the root file system to which the guest's
     ramdisk connects to during the guest boot process
    </para>
   </listitem>
   <listitem>
    <para>
     provide storage services to different customers from a single host file
     system in a cloud environment
    </para>
   </listitem>
  </itemizedlist>
  <section xml:id="kvm-qemu-virtfs-implement">
   <title>Implementation</title>
   <para>
    In &qemu;, the implementation of VirtFS is facilitated by defining two
    types of devices:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      <literal>virtio-9p-pci</literal> device which transports protocol
      messages and data between the host and the guest.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>fsdev</literal> device which defines the export file system
      properties, such as file system type and security model.
     </para>
    </listitem>
   </itemizedlist>
   <example xml:id="ex-qemu-virtfs-host">
    <title>Exporting Host's Filesystem with VirtFS</title>
<screen>qemu-kvm [...] -fsdev local,id=exp1<co xml:id="co-virtfs-host-id"/>,path=/tmp/<co xml:id="co-virtfs-host-path"/>,security_model=mapped<co xml:id="co-virtfs-host-sec-model"/>
-device virtio-9p-pci,fsdev=exp1<co xml:id="co-virtfs-host-fsdev"/>,mount_tag=v_tmp<co xml:id="co-virtfs-host-mnt-tag"/></screen>
    <calloutlist>
     <callout arearefs="co-virtfs-host-id">
      <para>
       Identification of the file system to be exported.
      </para>
     </callout>
     <callout arearefs="co-virtfs-host-path">
      <para>
       Filesystem path on the host to be exported.
      </para>
     </callout>
     <callout arearefs="co-virtfs-host-sec-model">
      <para>
       Security model to be used&mdash;<literal>mapped</literal> keeps the
       guest file system modes and permissions isolated from the host, while
       <literal>none</literal> invokes a <quote>pass-through</quote> security
       model in which permission changes on the guest's files are reflected on
       the host as well.
      </para>
     </callout>
     <callout arearefs="co-virtfs-host-fsdev">
      <para>
       The exported file system ID defined before with <literal>-fsdev
       id=</literal> .
      </para>
     </callout>
     <callout arearefs="co-virtfs-host-mnt-tag">
      <para>
       Mount tag used later on the guest to mount the exported file system.
      </para>
     </callout>
    </calloutlist>
    <para>
     Such an exported file system can be mounted on the guest like this
    </para>
<screen>mount -t 9p -o trans=virtio v_tmp /mnt</screen>
    <para>
     where <literal>v_tmp</literal> is the mount tag defined earlier with
     <literal>-device mount_tag=</literal> and <literal>/mnt</literal> is the
     mount point where you want to mount the exported file system.
    </para>
   </example>
  </section>
 </section>
 <section xml:id="kvm-qemu-ksm">
  <title>KSM: Sharing Memory Pages between Guests</title>
  <para>
   Kernel SamePage Merging (KSM) is a Linux Kernel feature which merges
   identical memory pages from multiple running processes into one memory
   region. Because &kvm; guests run as processes under Linux, KSM provides the
   memory overcommit feature to hypervisors for more efficient use of memory.
   Therefore, if you need to run multiple virtual machines on a host with
   limited memory, KSM is the best solution for you.
  </para>
  <para>
   To make use of KSM, do the following.
  </para>
  <procedure>
   <step>
    <para>
     Verify that KSM is enabled in your running Kernel:
    </para>
<screen>grep KSM /boot/config-`uname -r`
CONFIG_KSM=y</screen>
    <para>
     If KSM is enabled in the running Kernel, you will see the following files
     under the <filename>/sys/kernel/mm/ksm</filename> directory:
    </para>
<screen>ls -l /sys/kernel/mm/ksm
total 0
drwxr-xr-x 2 root root    0 Nov  9 07:10 ./
drwxr-xr-x 6 root root    0 Nov  9 07:10 ../
-r--r--r-- 1 root root 4096 Nov  9 07:10 full_scans
-r--r--r-- 1 root root 4096 Nov  9 07:10 pages_shared
-r--r--r-- 1 root root 4096 Nov  9 07:10 pages_sharing
-rw-r--r-- 1 root root 4096 Nov  9 07:10 pages_to_scan
-r--r--r-- 1 root root 4096 Nov  9 07:10 pages_unshared
-r--r--r-- 1 root root 4096 Nov  9 07:10 pages_volatile
-rw-r--r-- 1 root root 4096 Nov  9 07:10 run
-rw-r--r-- 1 root root 4096 Nov  9 07:10 sleep_millisecs</screen>
   </step>
   <step>
    <para>
     Check if KSM feature is turned on.
    </para>
<screen>cat /sys/kernel/mm/ksm/run</screen>
    <para>
     If the command returns <literal>0</literal>, turn KSM on with
    </para>
<screen>echo 1 &gt; /sys/kernel/mm/ksm/run</screen>
   </step>
   <step>
    <para>
     Now run several &vmguest;s under &kvm; and inspect the content of files
     <filename>pages_sharing</filename> and <filename>pages_shared</filename>,
     for example:
    </para>
<screen>while [ 1 ]; do cat /sys/kernel/mm/ksm/pages_shared; sleep 1; done
13522
13523
13519
13518
13520
13520
13528</screen>
   </step>
  </procedure>
  <para>
   For more information on the meaning of the
   <filename>/sys/kernel/mm/ksm/*</filename> files, see
   <filename>/usr/src/linux/Documentation/vm/ksm.txt</filename> (package
   <systemitem>kernel-source</systemitem>).
  </para>
 </section>
</chapter>
